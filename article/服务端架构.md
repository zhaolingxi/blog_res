## 1.背景与前言：
从某种传统的分类来说，程序员可以简单的划分为前后端，前端负责交互、展示，后端负责数据、计算。无论是早期的客户端界面与后台程序、还是后来流行的浏览器与远端服务、亦或是某些软件的云服务+本地混合计算的结构，后台软件始终以一种不间断的服务提供商的身份支撑业务运行；作为经验总结的一部分，本篇将阐述基础服务端的层级、架构、建设、维护，作为初入服务端的指导。

## 2.整体架构设计
服务总体可以简化设计为四层：
![[Pasted image 20260221094328.png]]
秉承着工程化的思想，我们并不建议在每一层自己重新造轮子，封装线程协程、自造数据库或者手搓搜索统计算法，都不在我们讨论的范畴，我们主要会聚焦于如何站在开源巨人的肩膀上，将我们的业务搭建运行起来。

## 3.分层级技术路线
驱动层：
所谓驱动在硬件层面的定义是：嵌入操作系统的有关硬件设备的信息程序。 此信息能够使计算机与相应的设备进行通信。我们这里指的是软件如何随着时间向前运行，常见的驱动方式有时间驱动（定时器）以及事件驱动（IO通知、调用通知等）。在软件层面，我们有很多种设计实现方式，包括epoll/IOCP/io_uring等等，我们这里不做一些设计模式上的争论，而是**选择一个成熟的异步运行时（runtime）**，让你的服务端程序能够在时间推进中持续运转、响应事件、调度任务、控制并发，并为上层（数据层/算法层/接口业务层）提供稳定一致的执行语义。鉴于我个人对于跨平台和省心的偏好，我这里以ASIO standlone作为驱动设计的蓝本。

驱动层主要把“服务端程序的持续运行”拆成 4 类可控的事情：
1. **事件驱动**：网络读写就绪、连接到来、DNS 解析完成、信号触发等。
2. **时间驱动**：定时任务、超时控制、重试退避（backoff）、心跳、过期回收等。
3. **并发调度**：多线程并行处理 I/O 与轻量逻辑，避免锁争用与竞态。
4. **任务编排**：把上层业务逻辑以“任务”的形式投递到合适的执行上下文中运行（避免阻塞事件循环）。

我们核心的工具有三个
1.并发线程池+io context上下文
相信学习过C++的同学都实现过多线程模型，不过在生产环境用，用手搓的简易线程池显然不够让人安心，

2.定时器timer（处理定时触发与超时控制）
定时任务，是系统中最常见，也是最好理解的任务执行方式，例如传感器上报信息、计算线程轮询接口等场景下，定时定频触发通常依赖于定时器，即硬件晶体时钟的定时消息发送。在时间触发的场景下，我们需要处理的情况分为两种：1.定时触发程序；2.超时异常处理。


3.多strand+post任务提交

数据层
在数据层，我们主要需要设计两类数据的存储，高频使用的内存数据、以及需要持久化和不频繁参与计算的数据库数据。
这里，我们将使用三个数据库作为核心工具：sqlite、postgresql、clickhouse，他们分别对应的场景是：单机简单服务、传统客户信息存取、统计服务

算法层：
以我的从业方向来说，常见算法主要集中于几何、约束求解、以及数理统计方面，所以，我们需要的工具有：engin、or-tools、gsl、clipper、

接口业务层：
接口业务分为两个方向，一个是面对集群业务的内部接口，常见于数据流，例如kafka、fastdds的数据传输接口，以及内部回调，一种则是面向用户，或者下游调用方的传统服务接口，作为服务端，我们需要暴露不同格式的调用接口，常见的调用方式主要分为直接调用（c-api）、跨语言调用（JS调用C++）、网络调用（http、websocket、tcp、udp），以及可能的简易状态机设计与处理。
我们分块来讲解：


## 4.性能优化与扩容
对于单机的优化方向，主要在多线程并发、热点函数处理、调试方向。
对于多实例的优化方向，主要在容器编排、数据传递。

## 5.典型业务场景实例(nginx + 软件实例 + nfs + kafka + mqtt + postgresql + clickhouse)
我们以汽车领域的车云计算，作为我们的业务示例，来讲一讲在业务场景下，我们的服务端是一个什么样的运行模式

## 6.持续集成
此处与行业的方式紧密相关，例如汽车行业的OTA、桌面软件更新、云服务的热更新

## 7.运维部署（docker swarm | k8s）
本机的服务应用，我们可以直接以安装包的形式安装运行，云端的服务，我们将使用docker打包环境后，使用容器编排技术运行