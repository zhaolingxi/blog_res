## 1.背景与前言：
从某种传统的分类来说，程序员可以简单的划分为前后端，前端负责交互、展示，后端负责数据、计算。无论是早期的客户端界面与后台程序、还是后来流行的浏览器与远端服务、亦或是某些软件的云服务+本地混合计算的结构，后台软件始终以一种不间断的服务提供商的身份支撑业务运行；作为经验总结的一部分，本篇将阐述基础服务端的层级、架构、建设、维护，作为初入服务端的指导。
![[Pasted image 20260225163130.png]]
## 2.业务模块整体架构设计
服务总体可以简化设计为：
![[Pasted image 20260221094328.png]]
秉承着工程化的思想，我们并不建议在每一层自己重新造轮子，封装线程协程、自造数据库或者手搓搜索统计算法，都不在我们讨论的范畴，我们主要会聚焦于如何站在开源巨人的肩膀上，将我们的业务搭建运行起来。

## 3.分层级技术路线
#### 驱动层：
所谓驱动在硬件层面的定义是：嵌入操作系统的有关硬件设备的信息程序。 此信息能够使计算机与相应的设备进行通信。我们这里指的是软件如何随着时间向前运行，常见的驱动方式有时间驱动（定时器）以及事件驱动（IO通知、调用通知等）。在软件层面，我们有很多种设计实现方式，包括epoll/IOCP/io_uring等等，我们这里不做一些设计模式上的争论，而是**选择一个成熟的异步运行时（runtime）**，让你的服务端程序能够在时间推进中持续运转、响应事件、调度任务、控制并发，并为上层（数据层/算法层/接口业务层）提供稳定一致的执行语义。鉴于我个人对于跨平台和省心的偏好，我这里以ASIO standlone作为驱动设计的蓝本。

驱动层主要把“服务端程序的持续运行”拆成 4 类可控的事情：
1. **事件驱动**：网络读写就绪、连接到来、DNS 解析完成、信号触发等。
2. **时间驱动**：定时任务、超时控制、重试退避（backoff）、心跳、过期回收等。
3. **并发调度**：多线程并行处理 I/O 与轻量逻辑，避免锁争用与竞态。
4. **任务编排**：把上层业务逻辑以“任务”的形式投递到合适的执行上下文中运行（避免阻塞事件循环）。

在使用层面上，我们核心的工具有三个
1.并发线程池+io context上下文
相信学习过C++的同学都实现过多线程模型，不过在生产环境用，用手搓的简易线程池显然不够让人安心，asio封装了epoll和iocp的调度模式，我们只需要创建多个线程，把他们统一加入io_context，并且调用run，后续就不用再维护，只需要提交任务即可，asio会自己帮我们执行。


2.定时器timer（处理定时触发与超时控制）
定时任务，是系统中最常见，也是最好理解的任务执行方式，例如传感器上报信息、计算线程轮询接口等场景下，定时定频触发通常依赖于定时器，即硬件晶体时钟的定时消息发送。在时间触发的场景下，我们需要处理的情况分为两种：1.定时触发程序；2.超时异常处理。


3.多strand+post任务提交
不是所有的任务都是独立、互不影响的，在很多时候我们需要任务按照一定的依赖顺序执行，这个时候就需要strand出场了，它能保证我们post上去的任务按照我们post的顺序执行，可能在直觉上这个很简单，但是在并发场景下，此时会有很多的麻烦需要处理，这也是asio省心的地方。

我们这里用asio 1.30作为讲解蓝本，不同版本的策略可能会不一样
asio里有io_context,一个io_context对应一个excutor，每一个io_context有一个全局的FIFO的任务队列（实际的实现加入了多层优化），所有的普通任务提交都到这里，然后按序执行，一个io_context共享一个线程池，每个线程都在调用run，每次run的时候，每个线程都会在全局队列没有写入的时候（锁竞争）按照任务插入顺序获取一个任务执行，普通任务立即执行，如果这是一个strand任务，就会有两种情况，一种是当前strand有任务正在跑，不知道需要多长时间，那就在提交的时候会提交到strand管理的等待队列中，这种任务每次执行完，就会把下一个的同属于一个strand的任务提交到就绪的队列中，如果当前strand本身就没有任务再运行，就直接推到就绪队列，然后整个strand去排队当作普通任务执行；多个io_context独立管理自己的任务和线程池。
需要注意的是这里有的教材会说asio的strand会采取内循环执行的策略，但是据我的观察，其源代码中为了避免长期占用线程，会重新投递和分配任务，代码如下：
```
std::size_t scheduler::do_run_one(mutex::scoped_lock& lock,
    scheduler::thread_info& this_thread,
    const asio::error_code& ec)
{
  while (!stopped_)
  {
    if (!op_queue_.empty())
    {
      // Prepare to execute first handler from queue.
      operation* o = op_queue_.front();
      op_queue_.pop();
      bool more_handlers = (!op_queue_.empty());

      if (o == &task_operation_)//strand入口
      {
        task_interrupted_ = more_handlers;

        if (more_handlers && !one_thread_)
          wakeup_event_.unlock_and_signal_one(lock);
        else
          lock.unlock();

        task_cleanup on_exit = { this, &lock, &this_thread };
        (void)on_exit;

        // Run the task. May throw an exception. Only block if the operation
        // queue is empty and we're not polling, otherwise we want to return
        // as soon as possible.
        task_->run(more_handlers ? 0 : -1, this_thread.private_op_queue);
      }
      else
      {
        std::size_t task_result = o->task_result_;

        if (more_handlers && !one_thread_)
          wake_one_thread_and_unlock(lock);
        else
          lock.unlock();

        // Ensure the count of outstanding work is decremented on block exit.
        work_cleanup on_exit = { this, &lock, &this_thread };
        (void)on_exit;

        // Complete the operation. May throw an exception. Deletes the object.
        o->complete(this, ec, task_result);
        this_thread.rethrow_pending_exception();

        return 1;
      }
    }
    else
    {
      wakeup_event_.clear(lock);
      wakeup_event_.wait(lock);
    }
  }

  return 0;
}
```

#### 数据层
在数据层，我们主要需要设计两类数据的存储，高频使用的内存数据、以及需要持久化和不频繁参与计算的数据库数据。
这里，我们将使用三个数据库作为核心工具：sqlite、postgresql、clickhouse，他们分别对应的场景是：单机简单服务、传统客户信息存取、统计服务
我们这里不去讲解数据库的实现，而是聚焦于怎么用数据库。


#### 算法层：
以我的从业方向来说，常见算法主要集中于几何、约束求解、以及数理统计方面，所以，我们需要的工具有：engin、or-tools、gsl、clipper等。


#### 接口业务层：
接口业务分为两个方向，一个是面对集群业务的内部接口，常见于数据流，例如kafka、fastdds的数据传输接口，以及内部回调，一种则是面向用户，或者下游调用方的传统服务接口，作为服务端，我们需要暴露不同格式的调用接口，常见的调用方式主要分为直接调用（c-api）、跨语言调用（常见于前端调用算法，例如JS调用C++）、网络接口调用（基于http、websocket、tcp、udp的业务接口），以及可能的简易状态机设计与处理。
我们分块来讲解：


## 4.性能优化与扩容
对于单机的优化方向，主要在多线程并发、热点函数处理、调试方向。
对于多实例的优化方向，主要在容器编排、数据传递。

## 5.典型业务场景实例(nginx + 软件实例 + nfs + kafka + mqtt + postgresql + clickhouse)
我们以汽车领域的车云计算，作为我们的业务示例，来讲一讲在业务场景下，我们的服务端是一个什么样的运行模式

## 6.持续集成
此处与行业的方式紧密相关，例如汽车行业的OTA、桌面软件更新、云服务的热更新

## 7.运维部署（docker swarm | k8s）
本机的服务应用，我们可以直接以安装包的形式安装运行，云端的服务，我们将使用docker打包环境后，使用容器编排技术运行